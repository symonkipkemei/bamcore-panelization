from __future__ import division
# -*- coding: utf-8 -*-

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> IMPORTS

from Autodesk.Revit.DB import *
from Autodesk.Revit.DB import Transaction, Element, ElementId, FilteredElementCollector
from Autodesk.Revit.DB.Structure import StructuralType
from Autodesk.Revit.UI.Selection import ObjectType

import clr

clr.AddReference("System")

from _create import _parts as g
from _create import _test as tt
from _create import _openings as o
from _create import _coordinate as c

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VARIABLES

app = __revit__.Application  # represents the Revit Autodesk Application
doc = __revit__.ActiveUIDocument.Document  # obj used to create new instances of elements within the active project
uidoc = __revit__.ActiveUIDocument  # obj that represent the current active project

rvt_year = int(app.VersionNumber)

# create
active_view = doc.ActiveView
active_level = doc.ActiveView.GenLevel


# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FUNCTIONS

def auto_reveal(host_wall_id, lap_type_id, variable_distance, side_of_wall):
    """ AUto generates a wall sweep reveal
    :param host_wall_id: id of the host wall
    :param variable_distance: distance from the default o, ( some fall outside the
    part and therefore v.d places it inside the part)
    :param side_of_wall: wall face to receive the reveal
    :return:  wall sweep created
    """

    # get part, this is the hosted element containing the part
    wall = doc.GetElement(host_wall_id)
    # get symbol
    wallSweepType = WallSweepType.Reveal
    # if this type is not available, instruct the user to download the family
    wallSweepTypeId = lap_type_id  # ElementId(352808)

    wallSweepInfo = WallSweepInfo(wallSweepType, True)
    wallSweepInfo.CutsWall = True
    wallSweepInfo.IsCutByInserts = True
    wallSweepInfo.Distance = variable_distance
    wallSweepInfo.WallSide = side_of_wall  # WallSide.Exterior
    wallSweepInfo.DistanceMeasuredFrom = DistanceMeasuredFrom.Base

    wall_sweep = WallSweep.Create(wall, wallSweepTypeId, wallSweepInfo)

    return wall_sweep


def auto_place_reveal(__title__, host_wall_id, lap_type_id, variable_distance, side_of_wall):
    """
    places an autogenerated reveal on a Part thus splitting into two
    :return:
    """
    with Transaction(doc, __title__) as t:
        t.Start()
        wall_sweep = auto_reveal(host_wall_id, lap_type_id, variable_distance, side_of_wall)
        t.Commit()

    return wall_sweep


def auto_place_reveal_v2(__title__, host_wall_id, lap_type_id, variable_distance, side_of_wall):
    """
    places an autogenerated reveal on a Part thus splitting into two, if reveal outside part, suppress dialogbox/warning
    :return:
    """
    with Transaction(doc, __title__) as t:
        try:
            t.Start("PlacingReveal")
            # get failure handling options
            options = t.GetFailureHandlingOptions()
            failureProcessor = tt.RevealWarningSwallower()
            options.SetFailuresPreprocessor(failureProcessor)
            t.SetFailureHandlingOptions(options)

            reveal = auto_reveal(host_wall_id, lap_type_id, variable_distance, side_of_wall)
            status = t.Commit()

            if status != TransactionStatus.Committed:
                    reveal = None

        except Exception as ex:
            if t.GetStatus() == TransactionStatus.Started:
                pass
            reveal = None

    print (reveal)

    return reveal


def auto_panel(__title__, host_wall_id, lap_type_id, reveal_indexes, side_of_wall):
    """
    Auto place reveals as per reveal indexes provided
    :param side_of_wall: The side of wall to be auto-paneled
    :param __title__: tool title
    :param host_wall_id: The host wall id
    :param reveal_indexes: a list of all reveal indexes
    :return: None
    """

    try:
        with Transaction(doc, __title__) as t:
            t.Start()
            for reveal_index in reveal_indexes:
                wall_sweep = auto_reveal(host_wall_id, lap_type_id, reveal_index, side_of_wall)
            t.Commit()

    except Exception as e:
        print ('The following error has occurred: {}'.format(e))


def auto_parts(__title__, part):
    """
    Identifies :
    1. the Parts ( exterior, interior or partition ) intuitively
    2. The lap (right or left) to be used to be used intuitively
    3. Direction to be used  right-> left or left->right intuitively
    :param part: Part to be panelized
    :param __title__: tool title
    :return: None
    """
    host_wall_id = g.get_host_wall_id(part)
    host_wall_type_id = g.get_host_wall_type_id(host_wall_id)
    layer_index = g.get_layer_index(part)
    left_lap_id = ElementId(352818)
    right_lap_id = ElementId(352808)

    variable_distance = 3
    # I_E_wall_types
    # BamCore 8" Separate I-E
    # BamCore 5" Separate I-E
    # BamCore 6 " Separate I-E
    # BamCore 8" Separate I-E 1 HR
    # BamCore 9 3/4" Seperate I-E

    I_E_wall_types = [ElementId(384173), ElementId(391917), ElementId(391949), ElementId(391949), ElementId(391971)]
    # I_wall_types
    # BamCore 8" Int Only
    I_wall_types = [ElementId(400084)]

    # filter non-edited wall

    if host_wall_type_id not in I_wall_types:
        if layer_index == 1:  # exterior face
            side_of_wall = WallSide.Exterior
            lap_type_id = right_lap_id

            left_edge, right_edge = g.get_edge_index(__title__, part, host_wall_id, lap_type_id, variable_distance,
                                                     side_of_wall)
            out_ranges = o.get_hosted_windows_out_range(__title__, part)
            reveal_indexes = g.get_reveal_indexes_v2(left_edge, right_edge, out_ranges, exterior=True)
            auto_panel(__title__, host_wall_id, lap_type_id, reveal_indexes, side_of_wall)

        elif layer_index == 3:  # interior face
            side_of_wall = WallSide.Interior
            lap_type_id = left_lap_id

            left_edge, right_edge = g.get_edge_index(__title__, part, host_wall_id, lap_type_id, variable_distance,
                                                     side_of_wall)
            out_ranges = o.get_hosted_windows_out_range(__title__, part)
            reveal_indexes = g.get_reveal_indexes_v2(left_edge, right_edge, out_ranges, exterior=False)
            auto_panel(__title__, host_wall_id, lap_type_id, reveal_indexes, side_of_wall)

    elif host_wall_type_id in I_wall_types:
        if layer_index == 2:  # interior face of partition walls, ignore layer-index 1 (the core)
            side_of_wall = WallSide.Interior
            lap_type_id = left_lap_id
            left_edge, right_edge = g.get_edge_index(__title__, part, host_wall_id, lap_type_id, variable_distance,
                                                     side_of_wall)

            reveal_indexes = g.get_reveal_indexes(left_edge, right_edge, exterior=False)
            auto_panel(__title__, host_wall_id, lap_type_id, reveal_indexes, side_of_wall)

    else:
        print ("This Wall type not recognized by the script \n\n"
               " Use either BamCore 8 Separate I-E or BamCore 8 Int Only"
               "Download and load Bamcore Template from: \n"
               "'https://github.com/symonkipkemei/panelization/tree/main/rvt-template'. \n"
               "Incase of any further errors raise an issue on : \n"
               " 'https://github.com/symonkipkemei/panelization/issues' \n")


def auto_adjust_wall_sweep_length(__title__, wall_sweep):
    """
    Adjust length of wall sweep so that it cuts the panel completely
    :param __title__: tool title
    :param wall_sweep: wall sweep to be adjusted
    :return: wall sweep adjusted
    """

    # get existing length of the wall parameter
    length_param = wall_sweep.get_Parameter(BuiltInParameter.CURVE_ELEM_LENGTH)
    print (length_param)
    current_length = length_param.AsDouble()

    # adjust length by an 1 inch to cut the panel completely
    new_length = current_length + 0.08

    with Transaction(doc, __title__) as t:
        t.Start()
        length_param.Set(new_length)
        t.Commit()
